{"ast":null,"code":"import { render, unmountComponentAtNode } from 'react-dom';\nimport * as React from 'react';\nimport toArray from \"rc-util/es/Children/toArray\"; // We only handle element & text node.\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar ellipsisContainer;\nvar wrapperStyle = {\n  padding: 0,\n  margin: 0,\n  display: 'inline',\n  lineHeight: 'inherit'\n};\n\nfunction pxToNumber(value) {\n  if (!value) return 0;\n  var match = value.match(/^\\d*(\\.\\d*)?/);\n  return match ? Number(match[0]) : 0;\n}\n\nfunction styleToString(style) {\n  // There are some different behavior between Firefox & Chrome.\n  // We have to handle this ourself.\n  var styleNames = Array.prototype.slice.apply(style);\n  return styleNames.map(function (name) {\n    return \"\".concat(name, \": \").concat(style.getPropertyValue(name), \";\");\n  }).join('');\n}\n\nfunction mergeChildren(children) {\n  var childList = [];\n  children.forEach(function (child) {\n    var prevChild = childList[childList.length - 1];\n\n    if (typeof child === 'string' && typeof prevChild === 'string') {\n      childList[childList.length - 1] += child;\n    } else {\n      childList.push(child);\n    }\n  });\n  return childList;\n}\n\nexport default (function (originEle, rows, content, fixedContent, ellipsisStr) {\n  if (!ellipsisContainer) {\n    ellipsisContainer = document.createElement('div');\n    ellipsisContainer.setAttribute('aria-hidden', 'true');\n    document.body.appendChild(ellipsisContainer);\n  } // Get origin style\n\n\n  var originStyle = window.getComputedStyle(originEle);\n  var originCSS = styleToString(originStyle);\n  var lineHeight = pxToNumber(originStyle.lineHeight);\n  var maxHeight = lineHeight * (rows + 1) + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom); // Set shadow\n\n  ellipsisContainer.setAttribute('style', originCSS);\n  ellipsisContainer.style.position = 'fixed';\n  ellipsisContainer.style.left = '0';\n  ellipsisContainer.style.height = 'auto';\n  ellipsisContainer.style.minHeight = 'auto';\n  ellipsisContainer.style.maxHeight = 'auto';\n  ellipsisContainer.style.top = '-999999px';\n  ellipsisContainer.style.zIndex = '-1000'; // clean up css overflow\n\n  ellipsisContainer.style.textOverflow = 'clip';\n  ellipsisContainer.style.whiteSpace = 'normal';\n  ellipsisContainer.style.webkitLineClamp = 'none'; // Render in the fake container\n\n  var contentList = mergeChildren(toArray(content));\n  render(React.createElement(\"div\", {\n    style: wrapperStyle\n  }, React.createElement(\"span\", {\n    style: wrapperStyle\n  }, contentList), React.createElement(\"span\", {\n    style: wrapperStyle\n  }, fixedContent)), ellipsisContainer); // wrap in an div for old version react\n  // Check if ellipsis in measure div is height enough for content\n\n  function inRange() {\n    return ellipsisContainer.offsetHeight < maxHeight;\n  } // Skip ellipsis if already match\n\n\n  if (inRange()) {\n    unmountComponentAtNode(ellipsisContainer);\n    return {\n      content: content,\n      text: ellipsisContainer.innerHTML,\n      ellipsis: false\n    };\n  } // We should clone the childNode since they're controlled by React and we can't reuse it without warning\n\n\n  var childNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes).filter(function (_ref) {\n    var nodeType = _ref.nodeType;\n    return nodeType !== COMMENT_NODE;\n  });\n  var fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);\n  unmountComponentAtNode(ellipsisContainer); // ========================= Find match ellipsis content =========================\n\n  var ellipsisChildren = [];\n  ellipsisContainer.innerHTML = ''; // Create origin content holder\n\n  var ellipsisContentHolder = document.createElement('span');\n  ellipsisContainer.appendChild(ellipsisContentHolder);\n  var ellipsisTextNode = document.createTextNode(ellipsisStr);\n  ellipsisContentHolder.appendChild(ellipsisTextNode);\n  fixedNodes.forEach(function (childNode) {\n    ellipsisContainer.appendChild(childNode);\n  }); // Append before fixed nodes\n\n  function appendChildNode(node) {\n    ellipsisContentHolder.insertBefore(node, ellipsisTextNode);\n  } // Get maximum text\n\n\n  function measureText(textNode, fullText) {\n    var startLoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var endLoc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : fullText.length;\n    var lastSuccessLoc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var midLoc = Math.floor((startLoc + endLoc) / 2);\n    var currentText = fullText.slice(0, midLoc);\n    textNode.textContent = currentText;\n\n    if (startLoc >= endLoc - 1) {\n      // Loop when step is small\n      for (var step = endLoc; step >= startLoc; step -= 1) {\n        var currentStepText = fullText.slice(0, step);\n        textNode.textContent = currentStepText;\n\n        if (inRange()) {\n          return step === fullText.length ? {\n            finished: false,\n            reactNode: fullText\n          } : {\n            finished: true,\n            reactNode: currentStepText\n          };\n        }\n      }\n    }\n\n    if (inRange()) {\n      return measureText(textNode, fullText, midLoc, endLoc, midLoc);\n    }\n\n    return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);\n  }\n\n  function measureNode(childNode, index) {\n    var type = childNode.nodeType;\n\n    if (type === ELEMENT_NODE) {\n      // We don't split element, it will keep if whole element can be displayed.\n      appendChildNode(childNode);\n\n      if (inRange()) {\n        return {\n          finished: false,\n          reactNode: contentList[index]\n        };\n      } // Clean up if can not pull in\n\n\n      ellipsisContentHolder.removeChild(childNode);\n      return {\n        finished: true,\n        reactNode: null\n      };\n    }\n\n    if (type === TEXT_NODE) {\n      var fullText = childNode.textContent || '';\n      var textNode = document.createTextNode(fullText);\n      appendChildNode(textNode);\n      return measureText(textNode, fullText);\n    } // Not handle other type of content\n    // PS: This code should not be attached after react 16\n\n\n    return {\n      finished: false,\n      reactNode: null\n    };\n  }\n\n  childNodes.some(function (childNode, index) {\n    var _measureNode = measureNode(childNode, index),\n        finished = _measureNode.finished,\n        reactNode = _measureNode.reactNode;\n\n    if (reactNode) {\n      ellipsisChildren.push(reactNode);\n    }\n\n    return finished;\n  });\n  return {\n    content: ellipsisChildren,\n    text: ellipsisContainer.innerHTML,\n    ellipsis: true\n  };\n});","map":{"version":3,"mappings":"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","names":["render","unmountComponentAtNode","React","toArray","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","ellipsisContainer","wrapperStyle","padding","margin","display","lineHeight","pxToNumber","value","match","Number","styleToString","style","styleNames","Array","prototype","slice","apply","map","name","getPropertyValue","join","mergeChildren","children","childList","forEach","child","prevChild","length","push","originEle","rows","content","fixedContent","ellipsisStr","document","createElement","setAttribute","body","appendChild","originStyle","window","getComputedStyle","originCSS","maxHeight","paddingTop","paddingBottom","position","left","height","minHeight","top","zIndex","textOverflow","whiteSpace","webkitLineClamp","contentList","inRange","offsetHeight","text","innerHTML","ellipsis","childNodes","cloneNode","filter","nodeType","fixedNodes","ellipsisChildren","ellipsisContentHolder","ellipsisTextNode","createTextNode","childNode","appendChildNode","node","insertBefore","measureText","textNode","fullText","startLoc","endLoc","lastSuccessLoc","midLoc","Math","floor","currentText","textContent","step","currentStepText","finished","reactNode","measureNode","index","type","removeChild","some"],"sources":["C:\\Users\\scs\\OneDrive\\Desktop\\Youtube Deploy\\client\\node_modules\\antd\\es\\typography\\typography\\util.jsx"],"sourcesContent":["import { render, unmountComponentAtNode } from 'react-dom';\nimport * as React from 'react';\nimport toArray from 'rc-util/lib/Children/toArray';\n// We only handle element & text node.\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\nlet ellipsisContainer;\nconst wrapperStyle = {\n    padding: 0,\n    margin: 0,\n    display: 'inline',\n    lineHeight: 'inherit',\n};\nfunction pxToNumber(value) {\n    if (!value)\n        return 0;\n    const match = value.match(/^\\d*(\\.\\d*)?/);\n    return match ? Number(match[0]) : 0;\n}\nfunction styleToString(style) {\n    // There are some different behavior between Firefox & Chrome.\n    // We have to handle this ourself.\n    const styleNames = Array.prototype.slice.apply(style);\n    return styleNames.map(name => `${name}: ${style.getPropertyValue(name)};`).join('');\n}\nfunction mergeChildren(children) {\n    const childList = [];\n    children.forEach((child) => {\n        const prevChild = childList[childList.length - 1];\n        if (typeof child === 'string' && typeof prevChild === 'string') {\n            childList[childList.length - 1] += child;\n        }\n        else {\n            childList.push(child);\n        }\n    });\n    return childList;\n}\nexport default (originEle, rows, content, fixedContent, ellipsisStr) => {\n    if (!ellipsisContainer) {\n        ellipsisContainer = document.createElement('div');\n        ellipsisContainer.setAttribute('aria-hidden', 'true');\n        document.body.appendChild(ellipsisContainer);\n    }\n    // Get origin style\n    const originStyle = window.getComputedStyle(originEle);\n    const originCSS = styleToString(originStyle);\n    const lineHeight = pxToNumber(originStyle.lineHeight);\n    const maxHeight = lineHeight * (rows + 1) +\n        pxToNumber(originStyle.paddingTop) +\n        pxToNumber(originStyle.paddingBottom);\n    // Set shadow\n    ellipsisContainer.setAttribute('style', originCSS);\n    ellipsisContainer.style.position = 'fixed';\n    ellipsisContainer.style.left = '0';\n    ellipsisContainer.style.height = 'auto';\n    ellipsisContainer.style.minHeight = 'auto';\n    ellipsisContainer.style.maxHeight = 'auto';\n    ellipsisContainer.style.top = '-999999px';\n    ellipsisContainer.style.zIndex = '-1000';\n    // clean up css overflow\n    ellipsisContainer.style.textOverflow = 'clip';\n    ellipsisContainer.style.whiteSpace = 'normal';\n    ellipsisContainer.style.webkitLineClamp = 'none';\n    // Render in the fake container\n    const contentList = mergeChildren(toArray(content));\n    render(<div style={wrapperStyle}>\n      <span style={wrapperStyle}>{contentList}</span>\n      <span style={wrapperStyle}>{fixedContent}</span>\n    </div>, ellipsisContainer); // wrap in an div for old version react\n    // Check if ellipsis in measure div is height enough for content\n    function inRange() {\n        return ellipsisContainer.offsetHeight < maxHeight;\n    }\n    // Skip ellipsis if already match\n    if (inRange()) {\n        unmountComponentAtNode(ellipsisContainer);\n        return { content, text: ellipsisContainer.innerHTML, ellipsis: false };\n    }\n    // We should clone the childNode since they're controlled by React and we can't reuse it without warning\n    const childNodes = Array.prototype.slice\n        .apply(ellipsisContainer.childNodes[0].childNodes[0].cloneNode(true).childNodes)\n        .filter(({ nodeType }) => nodeType !== COMMENT_NODE);\n    const fixedNodes = Array.prototype.slice.apply(ellipsisContainer.childNodes[0].childNodes[1].cloneNode(true).childNodes);\n    unmountComponentAtNode(ellipsisContainer);\n    // ========================= Find match ellipsis content =========================\n    const ellipsisChildren = [];\n    ellipsisContainer.innerHTML = '';\n    // Create origin content holder\n    const ellipsisContentHolder = document.createElement('span');\n    ellipsisContainer.appendChild(ellipsisContentHolder);\n    const ellipsisTextNode = document.createTextNode(ellipsisStr);\n    ellipsisContentHolder.appendChild(ellipsisTextNode);\n    fixedNodes.forEach(childNode => {\n        ellipsisContainer.appendChild(childNode);\n    });\n    // Append before fixed nodes\n    function appendChildNode(node) {\n        ellipsisContentHolder.insertBefore(node, ellipsisTextNode);\n    }\n    // Get maximum text\n    function measureText(textNode, fullText, startLoc = 0, endLoc = fullText.length, lastSuccessLoc = 0) {\n        const midLoc = Math.floor((startLoc + endLoc) / 2);\n        const currentText = fullText.slice(0, midLoc);\n        textNode.textContent = currentText;\n        if (startLoc >= endLoc - 1) {\n            // Loop when step is small\n            for (let step = endLoc; step >= startLoc; step -= 1) {\n                const currentStepText = fullText.slice(0, step);\n                textNode.textContent = currentStepText;\n                if (inRange()) {\n                    return step === fullText.length\n                        ? {\n                            finished: false,\n                            reactNode: fullText,\n                        }\n                        : {\n                            finished: true,\n                            reactNode: currentStepText,\n                        };\n                }\n            }\n        }\n        if (inRange()) {\n            return measureText(textNode, fullText, midLoc, endLoc, midLoc);\n        }\n        return measureText(textNode, fullText, startLoc, midLoc, lastSuccessLoc);\n    }\n    function measureNode(childNode, index) {\n        const type = childNode.nodeType;\n        if (type === ELEMENT_NODE) {\n            // We don't split element, it will keep if whole element can be displayed.\n            appendChildNode(childNode);\n            if (inRange()) {\n                return {\n                    finished: false,\n                    reactNode: contentList[index],\n                };\n            }\n            // Clean up if can not pull in\n            ellipsisContentHolder.removeChild(childNode);\n            return {\n                finished: true,\n                reactNode: null,\n            };\n        }\n        if (type === TEXT_NODE) {\n            const fullText = childNode.textContent || '';\n            const textNode = document.createTextNode(fullText);\n            appendChildNode(textNode);\n            return measureText(textNode, fullText);\n        }\n        // Not handle other type of content\n        // PS: This code should not be attached after react 16\n        return {\n            finished: false,\n            reactNode: null,\n        };\n    }\n    childNodes.some((childNode, index) => {\n        const { finished, reactNode } = measureNode(childNode, index);\n        if (reactNode) {\n            ellipsisChildren.push(reactNode);\n        }\n        return finished;\n    });\n    return {\n        content: ellipsisChildren,\n        text: ellipsisContainer.innerHTML,\n        ellipsis: true,\n    };\n};\n"]},"metadata":{},"sourceType":"module"}